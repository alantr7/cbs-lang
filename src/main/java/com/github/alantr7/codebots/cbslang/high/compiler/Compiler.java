package com.github.alantr7.codebots.cbslang.high.compiler;

import com.github.alantr7.codebots.cbslang.exceptions.ParserException;
import com.github.alantr7.codebots.cbslang.high.parser.Parser;
import com.github.alantr7.codebots.cbslang.high.parser.ast.AST;
import com.github.alantr7.codebots.cbslang.high.parser.ast.expressions.*;
import com.github.alantr7.codebots.cbslang.high.parser.ast.objects.*;
import com.github.alantr7.codebots.cbslang.high.parser.ast.statements.*;
import com.github.alantr7.codebots.cbslang.low.runtime.Program;
import com.github.alantr7.codebots.cbslang.low.runtime.ProgramExecutor;
import lombok.Getter;

import java.util.ArrayList;
import java.util.List;

public class Compiler {

    private final CompilerContext context = new CompilerContext();

    public final AST ast;

    private final StringBuilder builder = new StringBuilder();

    private int autogenerated_labelId = 0;

    public Compiler(AST ast) {
        this.ast = ast;
    }

    @Getter
    private final Scope globalScope = new Scope();

    public void experimentalCompile() {
        ast.constants.forEach((val) -> {
            if (val.type == Primitive.INT)
                compileConstant("int", val.value);
            else if (val.type == Primitive.FLOAT)
                compileConstant("flt", val.value);
            else if (val.type == Primitive.STRING)
                compileConstant("str", val.value);
        });
        compileSignatures();

        // compile main first
        List<Function> functions = new ArrayList<>(ast.functions.values());
        for (int i = 0; i < functions.size(); i++) {
            Function function = functions.get(i);
            if (function.signature.name.equals("main") && function.signature.module == null) {
                functions.set(i, functions.get(0));
                functions.set(0, function);
                break;
            }
        }
        functions.forEach(this::compileFunction);
    }

    public void compileConstant(String type, Object value) {
        builder.append("defc ").append(type).append(", ").append(value).append("\n");
    }

    public void compileSignatures() {
        builder.append("; Imports\n");
        for (FunctionSignature signature : ast.signatures) {
            if (signature.module != null) {
                builder.append("impf ").append(signature.module).append(", ").append(signature.name).append("\n");
            }
        }
        builder.append("\n");
    }

    public void compileFunction(Function function) {
        builder.append("; Function: ").append(function.signature.name).append("(").append(")").append("\n");
        builder.append(function.signature.name).append(":\n");

        context.currentFunction = function.signature;

        if (!function.signature.name.equals("main")) {
            builder.append("push ebp\n");
            builder.append("mov ebp, esp\n");
            builder.append("sub ebp, 1\n");
        } else {
            // without this it breaks when using constants
            builder.append("push ebp\n");
            builder.append("mov ebp, esp\n");
            builder.append("sub ebp, 1\n");
        }

        for (Statement stmt : function.body) {
            compileStatement(stmt);
        }

        // todo: variable cleanup

        context.currentFunction = null;

        builder.append("\n");
    }

    private void compileIf(If ifs, int resultId, boolean isMain) {
        int labelId = autogenerated_labelId++;

        // Compile the chain.
        if (ifs.expression != null) {
            compileExpression(ifs.expression);
            builder.append("pop eax\n");
            builder.append("cmp eax, 1\n");
            builder.append("jne if_after_body").append(labelId).append("\n");
        }

        // Body
        for (Statement stmt : ifs.body) {
            compileStatement(stmt);
        }
        builder.append("jmp if_after").append(resultId).append("\n");

        builder.append("if_after_body").append(labelId).append(":\n");

        // Elses
        if (ifs.elseStmt != null) {
            compileIf(ifs.elseStmt, resultId, false);
        }

        // Label after the if statements chain
        if (isMain) {
            builder.append("if_after").append(resultId).append(":\n");
        }
    }

    private void compileWhile(While loop) {
        int labelId = autogenerated_labelId++;

        builder.append("loop_start").append(labelId).append(":\n");

        // Compile loop condition.
        compileExpression(loop.expression);
        builder.append("pop eax\n");
        builder.append("cmp eax, 1\n");
        builder.append("jne loop_after").append(labelId).append("\n");

        // Body
        for (Statement stmt : loop.body) {
            compileStatement(stmt);
        }
        builder.append("jmp loop_start").append(labelId).append("\n");

        // Label after the loop
        builder.append("loop_after").append(labelId).append(":\n");
    }

    private void compileDoWhile(While loop) {
        int labelId = autogenerated_labelId++;

        builder.append("loop_start").append(labelId).append(":\n");

        // Compile loop condition.
        compileExpression(loop.expression);
        builder.append("pop eax\n");
        builder.append("cmp eax, 1\n");
        builder.append("jne loop_after").append(labelId).append("\n");

        // Body
        for (Statement stmt : loop.body) {
            compileStatement(stmt);
        }
        builder.append("jmp loop_start").append(labelId).append("\n");

        // Label after the loop
        builder.append("loop_after").append(labelId).append(":\n");
    }

    private void compileFor(For loop) {
        int labelId = autogenerated_labelId++;

        if (loop.init != null) {
            if (loop.init instanceof Operand expr) {
                compileExpression(expr);
                append("pop");
            } else if (loop.init instanceof Declare declare)
                compileVariableDeclare(declare);
        }

        builder.append("loop_start").append(labelId).append(":\n");

        // Compile loop condition.
        compileExpression(loop.condition);
        builder.append("pop eax\n");
        builder.append("cmp eax, 1\n");
        builder.append("jne loop_after").append(labelId).append("\n");

        // Body
        for (Statement stmt : loop.body) {
            compileStatement(stmt);
        }

        // Update
        if (loop.update != null) {
            compileExpression(loop.update);
            append("pop");
        }

        builder.append("jmp loop_start").append(labelId).append("\n");

        // Label after the loop
        builder.append("loop_after").append(labelId).append(":\n");
    }

    public void compileStatement(Statement statement) {
        if (statement instanceof Call call) {
            compileExpression(call);
            builder.append("pop\n");
        }

        else if (statement instanceof While loop) {
            if (loop.isDoWhile) {
                compileDoWhile(loop);
            } else {
                compileWhile(loop);
            }
        }

        else if (statement instanceof If ifs) {
            compileIf(ifs, autogenerated_labelId, true);
        }

        else if (statement instanceof Declare declare) {
            compileVariableDeclare(declare);
        }

        else if (statement instanceof Assign assign) {
            compileExpression(assign);
            append("pop");
        }

        else if (statement instanceof For loop) {
            compileFor(loop);
        }

        else if (statement instanceof Operand expression) {
            compileExpression(expression);
            append("pop");
        }

        else if (statement instanceof Ret ret) {
            compileExpression(ret.value);
            builder.append("pop rax\n");

            if (context.currentFunction.name.equals("main")) {
                builder.append("exit\n");
            } else {
                builder.append("ret\n");
            }
        }
    }

    public void compileExpression(Operand operand) {
        if (operand instanceof Literal literal) {
            if (literal.type == Literal.INT) {
                builder.append("push ").append(literal.value.intValue()).append("\n");
            }
            else if (literal.type == Literal.FLOAT) {
                builder.append("push [").append(ast.getConstantAddress(literal.value)).append("]").append("\n");
            }
        } else if (operand instanceof Operator operator) {
            String operatorCommand = switch (operator.type) {
                case ProgramExecutor.ADD -> "add";
                case ProgramExecutor.SUB -> "sub";
                case ProgramExecutor.MUL -> "mul";
                case ProgramExecutor.DIV -> "div";


                default -> null;
            };
            builder.append(operatorCommand).append(" [esp-2], [esp-1]").append("\n");
            builder.append("pop").append("\n");
        } else if (operand instanceof Logical logical) {
            builder.append("; Logical expression\n");
            for (int i = 2; i < logical.operands.length; i += 2) {
                int labelId = autogenerated_labelId++;

                Operand left = logical.operands[i - 2];
                compileExpression(left);
                builder.append("pop eax\n");
                builder.append("cmp eax, 0\n");

                byte operator = ((Operator) logical.operands[i - 1]).type;
                if (operator == Logical.OR) {
                    builder.append("jne success").append(labelId).append("\n");
                } else {
                    builder.append("je fail").append(labelId).append("\n");
                }
                builder.append("\n");

                Operand right = logical.operands[i];
                compileExpression(right);

                builder.append("pop eax\n");
                builder.append("cmp eax, 0\n");
                if (operator == Logical.OR) {
                    builder.append("jne success").append(labelId).append("\n");
                } else {
                    builder.append("je fail").append(labelId).append("\n");
                }
                builder.append("\n");

                if (operator == Logical.OR) {
                    builder.append("push 0\n");
                    builder.append("jmp after").append(labelId).append("\n");;
                    builder.append("success").append(labelId).append(":\n");;
                    builder.append("push 1\n\n");
                    builder.append("after").append(labelId).append(":\n");;
                } else {
                    builder.append("push 1\n");
                    builder.append("jmp after").append(labelId).append("\n");;
                    builder.append("fail").append(labelId).append(":\n");;
                    builder.append("push 0\n\n");
                    builder.append("after").append(labelId).append(":\n");;
                }
            }
        } else if (operand instanceof Arithmetic arithmetic) {
            builder.append("; Arithmetic expression\n");
            for (Operand operand1 : arithmetic.operands) {
                compileExpression(operand1);
            }
            builder.append("\n");
        } else if (operand instanceof Assign assign) {
            builder.append("; Variable assign\n");
            compileExpression(assign.value);

            // Compiles indices and saves them on stack
            for (int i = 0; i < assign.indices.length; i++) {
                builder.append("; Index ").append(i).append("\n");
                compileExpression(assign.indices[i]);
            }

            // Pops all indices from stack and calculates the offset
            builder.append("mov eax, ").append(assign.variable.offset).append("\n");
            for (int i = assign.indices.length - 1; i >= 0; i--) {
                builder.append("; ").append(i).append(". operand\n");
                builder.append("pop ebx\n");

                if (i != 0)
                    builder.append("mul ebx, ").append(assign.variable.lengths[i]).append("\n");

                builder.append("add eax, ebx\n");
            }

            builder.append("mov [").append(assign.variable.global ? "eax" : ("ebp+" + "eax")).append("], [esp-1]\n");
            builder.append("\n");
        } else if (operand instanceof Access access) {
            builder.append("; Variable access\n");

            // Compiles indices and saves them on stack
            for (int i = 0; i < access.indices.length; i++) {
                builder.append("; Index ").append(i).append("\n");
                compileExpression(access.indices[i]);
            }

            // Pops all indices from stack and calculates the offset
            builder.append("mov eax, ").append(access.variable.offset).append("\n");
            for (int i = access.indices.length - 1; i >= 0; i--) {
                builder.append("; ").append(i).append(". operand\n");
                builder.append("pop ebx\n");

                if (i != 0)
                    builder.append("mul ebx, ").append(access.variable.lengths[i]).append("\n");

                builder.append("add eax, ebx\n");
            }

            builder.append("push [").append(access.variable.global ? "eax" : ("ebp+" + "eax")).append("]\n");
        } else if (operand instanceof Call call) {
            builder.append("; Function call\n");

            for (Operand[] argument : call.arguments) {
                for (Operand operand1 : argument) {
                    compileExpression(operand1);
                }
            }

            if (call.function.module != null) {
                builder.append("push ").append(call.arguments.length).append("\n");
            }

            builder.append("call ").append(call.function.module != null ? ("." + ast.getFunctionOffset(call.function)) : call.function.name).append("\n");
            if (call.function.module != null) {
                builder.append("sub esp, ").append(1 + call.arguments.length).append("\n");
            } else {
                builder.append("sub esp, ").append(call.arguments.length).append("\n");
            }
            builder.append("push rax\n");
        } else if (operand instanceof Compare compare) {
            int labelId = autogenerated_labelId++;
            compileExpression(compare.left);
            compileExpression(compare.right);

            builder.append("cmp [esp-2], [esp-1]\n");
            builder.append("sub esp, 2\n");
            switch (compare.operation) {
                case Compare.EQUALS -> builder.append("jne fail").append(labelId).append("\n");
                case Compare.NOT_EQUALS -> builder.append("je fail").append(labelId).append("\n");
                case Compare.LESS_THAN -> builder.append("jge fail").append(labelId).append("\n");
                case Compare.GREATER_THAN -> builder.append("jle fail").append(labelId).append("\n");
                case Compare.LESS_EQUALS -> builder.append("jg fail").append(labelId).append("\n");
                case Compare.GREATER_EQUALS -> builder.append("jl fail").append(labelId).append("\n");
            };

            builder.append("push 1\n");
            builder.append("jmp after").append(labelId).append("\n");

            builder.append("fail").append(labelId).append(":\n");
            builder.append("push 0\n");

            builder.append("after").append(labelId).append(":\n");
            builder.append("\n");

            // Both results are now in stack
        }

        else if (operand instanceof Unary unary) {
            builder.append("; Unary\n");
            // if prefix
            if (unary.operation == Unary.PREFIX_INCREMENT || unary.operation == Unary.PREFIX_DECREMENT) {
                compileExpression(new Assign(unary.operand.variable, unary.operand.indices, new Arithmetic(new Operand[]{
                  unary.operand,
                  new Literal(Literal.INT, unary.operation == Unary.PREFIX_INCREMENT ? 1 : -1),
                  Operator.ADD
                })));
            }
            else {
                builder.append("; Push variable onto stack\n");
                compileExpression(unary.operand); // pushes variable value onto the stack
                builder.append("; Update variable\n");
                compileExpression(new Assign(unary.operand.variable, unary.operand.indices, new Arithmetic(new Operand[]{
                  unary.operand,
                  new Literal(Literal.INT, unary.operation == Unary.POSTFIX_INCREMENT ? 1 : -1),
                  Operator.ADD
                })));
                builder.append("pop\n");
            }
        }

        else if (operand instanceof Cast cast) {
            builder.append("; Cast\n");
            compileExpression(cast.operand);
            if (cast.operand.getResultType() == Primitive.FLOAT && cast.type == Primitive.INT) {
                builder.append("cflti\n");
            }
            else if (cast.operand.getResultType() == Primitive.INT && cast.type == Primitive.FLOAT) {
                builder.append("ciflt\n");
            }
            // todo: maybe throw an error, it shouldn't be anything else cause parser took care of it
        }

        else if (operand instanceof Concat concat) {
            builder.append("; string concat\n");
            compileExpression(concat.left);
            compileExpression(concat.right);
            builder.append("cat").append(" [esp-2], [esp-1]").append("\n");
            builder.append("pop").append("\n");
        }
    }

    public void compileVariableDeclare(Variable declare) {
        builder.append("; Variable declare\n");
        builder.append("add esp, ").append(declare.length).append("\n");
    }

    public void compileVariableDeclare(Declare declare) {
        builder.append("; Variable declare\n");
        int sum = 0;
        for (int len : declare.lengths)
            sum += len;

        if (declare.value != null) {
            compileExpression(declare.value);
            // todo: don't i need to pop here?
        } else {
            builder.append("add esp, ").append(sum).append("\n");
        }
    }

    public void append(String string) {
        builder.append(string).append("\n");
    }

    public String getOutput() {
        return builder.toString();
    }

    public static Program compile(String code) throws ParserException {
        AST ast = Parser.parse(code);
        return null;
    }

}
